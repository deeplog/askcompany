# 장고 Forms



목차  
------

[1. HTML Form](#1.-HTML-FORM)

[2. HTTPRequest & HTTPResponse](#2.-HTTPRequest-&-HTTPResponse)

[3. Django Form](#3.-Django-Form)

[4. CSR](#4.-CSR)

[5. ModelForm](#5,-ModelForm)

[6. Form Valication](#6,-Form-Valication)

[7. Message Framework](#7.-Message-Framework)

[8.Forms를 통한 삭제 구현](#8.-Forms를-통한-삭제-구현)

   



## 개요

### 기본 구조

![PostForm](images\PostForm.png)



### 코드

```python
# models.py
class Post(models.Model):
    message = models.TextField(
        validators=[MinLengthValidator(10)]
    )  # 최소 10글자 제약 유효성 검사, admin단에서도 바로 확인 가능
```

```python
# forms.py

from django import forms
from .models import Post
# 모델 Form  설계
class PostForm(forms.ModelForm):
    class Meta:
        model = Post
        fields = "__all__"
```

```python
#views.py

def post_new(request):
    if request.method == "POST":
        form = PostForm(request.POST, request.FILES)
        if form.is_valid():
            post = form.save()  # 방금 저장한 모델 인스턴스 반환
            return redirect(post)  # 저장을 하고 이동이 되게 한다.
    else:
        form = PostForm()

    return render(
        request,
        "instagram/post_form.html",  # 폼을 보여준다.
        {
            "form": form,
        },
    )

```

```html
<!--post_form.html

<form action="" method="post" enctype="multipart/form-data">
    {% csrf_token %}
    <!-- 폼을 쓸때는 테이블로 감싸야 된다. -->
    <table>
        {{ form }}
    </table>
    <input type="submit" value="저장" />
</form>
```

```python
#urls.py
urlpatterns = [
    path("new/", views.post_new, name="post_new"),
]
```



##  1. HTML Form

### 개요

* HTML  Form
  * 사용장에게 입력폼을 제공하고 이를 서버로 전송한다. <form> 태그 활용 
* Django Form
  * 유효성을 검사한다. 
  * Get/Post 요청을 보내면 서버에서 응답 HTML을 보내줌

### HTML Form

* 구성요소

  * < form>  태그 - 입력폼 구성
  * action - 요청을 보내 주소임. 해당 url로 데이터 전송을 시도
  * method : 전송방식
    * Get - 데이터 조회시 활용
    * Post - 생성/수정/삭제에서 사용
  * enctype - 인코딩 방식
  * widget 

* 코드

  ```html
  <form action="" method="POST">
      <input type="text" /> <!-- 1줄 문자열 입력 -->
      <textarea></textarea> <!-- 1줄 이상의 문자열 입력 -->
      <select></select> <!-- 항목 중 택일 -->
      <input type="checkbox" /> <!-- 체크박스 (한 그룹 내 여러 항목을 다수 선택 가능) -->
      <input type="radio" /> <!-- 라디오박스 (한 그룹 내 여러 항목 중에 하나만 선택 가능) -->
      그 외 다수 위젯
  </form>
  ```

*  Form의 enctype

  * "application/x-www-form-urlencoded" (디폴트)

    Get 방식에서 강제됨   

    파일 업로드는 불가

    URL 인코딩을 통해서 인자들을 QueryString 형태로 전달

    <img src="images\url인코딩.png" style="zoom:80%;" />

  * "multipart/form-data"

    * 파일 업로드 가능

#### url encode

*  key=value의 값의 쌍이 & 문자로 이어진 형태

* utf8 인코딩 방식을 사용한다. 

  ```python
  from urllib.parse import urlencode
  print(urlencode({'key1': 'value1', 'key2': 10, 'name': '방탄소년단'}))
  print('방탄소년단'.encode('utf8'))
  print(''.join('%{:X}'.format(ch) for ch in '방탄소년단'.encode('utf8')))
  
  ### 결과 
  key1=value1&key2=10&name=%EB%B0%A9%ED%83%84%EC%86%8C%EB%85%84%EB%8B%A8
  b'\xeb\xb0\xa9\xed\x83\x84\xec\x86\x8c\xeb\x85\x84\xeb\x8b\xa8'
  %EB%B0%A9%ED%83%84%EC%86%8C%EB%85%84%EB%8B%A8
  ```

#### Form Method

* Form  요청에서 인자를 보내는 2가지 방법

* 요청 URL 뒤에 ? 를 붙이고 인자를 실어서 보내기

  *  QueryString 활용 

* 요청 Body에 모든 인코딩의 인자를 실어서 보내는 방법

  * Get 요청에서는 Header만 존재한다. 
  * Post 요청에서는 Body 존재한다. 
  * Client ->  서버로 요청하거나 서버에서 응답할때도 사용한다.

* Get 방식

  * 메세지만 보낼 수 있다.

  * Header 만 있다.

    ```html
    <form method="GET" action="">
        <input type="text" name="query" />
        <input type="submit" value="검색" />
    </form>
    ```

    <form method="GET" action="">
        <input type="text" name="query" />
        <input type="submit" value="검색" />
    </form>
    
    

    ```html
    ## 이렇게 하면 안됨
    <form method="GET" action="">
        <input type="text" name="title" />
        <textarea name="content"></textarea>
        <input type="file" name="photo" />
        <input type="submit" value="저장" />
    </form>
    ```

    

* Post 방식

  * 데이터도 보낼 수 있다.

  * Header + Body가 있다.

    ```html
    <form method="POST" action="" enctype="multipart/form-data">
        <input type="text" name="title" />
        <textarea name="content"></textarea>
        <input type="file" name="photo" />
        <input type="submit" value="저장" />
    </form>
    ```

* 장고 View 에서의 인자 접근

  * request.GET
    * 모든 QueryString 인자 목록
    * QueryString을 파싱한 QueryDict 객체
    * GET/POST 요청에서 모두 가능
  * request.POST
    * POST 요청에서만 가능.
    * 파일 내역은 제외한 모든 POST인자 목록
    * "요청 BODY"를 파싱한 QueryDict 객체
  * request.FILES
    * POST 요청에서만 가능.
    * "요청 BODY"에서 파일내역만 파싱한 MultiValueDict 객체

[목차로 이동](#목차)   

## 2. HTTPRequest & HTTPResponse

### HTTPRequest 객체

* 클라인언트로부터 모든 요청 내용을 담고 있다. 
* .GET, .POST, .FILES  인자를 통해 참조할 수 있다.

#### MultiValueDict

* dict을 상속받은 클래스

* 동일키 다수 value를 지원하는 사전

* name=Tom&name=Steve&name=Tomi

* https://github.com/django/django/blob/3.0.2/django/utils/datastructures.py#L42

  ```python
  >>>	from django.utils.datastructures	import MultiValueDict
  >>>	d	=	MultiValueDict({'name':	['Adrian',	'Simon'],	'position':	['Developer']})
  >>>	d['name'] # dict과 동일하게 동작. 단일값을 획득
  'Simon'
  >>>	d.getlist('name') # 다수값 획득을 시도. 리스트를 반환
  ['Adrian',	'Simon']
  >>>	d.getlist('doesnotexist')		# 없는 Key에 접근하면 빈 리스트를 반환
  []
  >>>	d['name']	=	'changed'
  >>>	d
  <MultiValueDict:	{'name':	['changed'],	'position':	['Developer']}
  ```

#### QueryDict

```python
class QueryDict(MultiValueDict):
    _mutable	=	True
    _encoding	=	None
    def __init__(self,	query_string=None,	mutable=False,	encoding=None):
        #	...
        self._mutable	=	mutable
    def _assert_mutable(self):
        if not self._mutable:
        raise AttributeError("This	QueryDict	instance	is	immutable")
    def __setitem__(self,	key,	value):
        self._assert_mutable()
        #	...
    def __delitem__(self,	key):
        self._assert_mutable()
        #	...
        #	...
```

### HTTPResponse

* 이미지, HTML 문자열등, 다양한 응답을 wrapping

* View에서는 반환값으로서 HttpResponse를 기대한다. 

* MiddleWare

  ```python
  #	프로젝트/settings
  MIDDLEWARE	=	[
      'django.middleware.security.SecurityMiddleware',
      'django.contrib.sessions.middleware.SessionMiddleware',
      'django.middleware.common.CommonMiddleware',
      'django.middleware.csrf.CsrfViewMiddleware',
      'django.contrib.auth.middleware.AuthenticationMiddleware',
      'django.contrib.messages.middleware.MessageMiddleware',
      'django.middleware.clickjacking.XFrameOptionsMiddleware',
  ]
  ```

  ![image-20221016071345611](images\HTTPRequest전달.png)

#### Filelike 객체

```python
response	=	HttpResponse(
    "<p>Here's	the	text	of	the	Web	page.</p>"
    "<p>Here's	another	paragraph.</p>"
)
response	=	HttpResponse()
response.write("<p>Here's	the	text	of	the	Web	page.</p>")
response.write("<p>Here's	another	paragraph.</p>")
```

#### JsonResponse

웹 API 응답을 할 때 사용하는 포맷의 한 종류

https://docs.djangoproject.com/en/2.1/ref/request-response/#jsonresponse-objects

```python
from django.core.serializers.json	import DjangoJSONEncoder
class JsonResponse(HttpResponse):
    def __init__(self,	data,	encoder=DjangoJSONEncoder,	safe=True,
    	json_dumps_params=None,	**kwargs):
    if safe	and not isinstance(data,	dict):
    	raise TypeError(
    		'In	order	to	allow	non-dict	objects	to	be	serialized	set	the	'
    		'safe	parameter	to	False.')
    if json_dumps_params	is None:
    	json_dumps_params	=	{}
    kwargs.setdefault('content_type',	'application/json')
    data	=	json.dumps(data,	cls=encoder,	**json_dumps_params)
    super().__init__(content=data,	**kwargs)
```

#### StreamingHttpResponse

* 긴 응답을 효율적으로 처리하기 위함

* 조금씩 생성할때 마다 응답을 준다. 

* 큰 응답시에는 극심한 성능 저하로 이어질 수 있음.

  https://docs.djangoproject.com/en/3.0/howto/outputting-csv/

  ```python
  import csv
  
  from django.http import StreamingHttpResponse
  
  class Echo:
      """An object that implements just the write method of the file-like
      interface.
      """
      def write(self, value):
          """Write the value by returning it, instead of storing in a buffer."""
          return value
  
  def some_streaming_csv_view(request):
      """A view that streams a large CSV file."""
      # Generate a sequence of rows. The range is based on the maximum number of
      # rows that can be handled by a single sheet in most spreadsheet
      # applications.
      rows = (["Row {}".format(idx), str(idx)] for idx in range(65536)) #Generator
      pseudo_buffer = Echo()
      writer = csv.writer(pseudo_buffer)
      response = StreamingHttpResponse((writer.writerow(row) for row in rows), #Generator 표현식
                                       content_type="text/csv")
      response['Content-Disposition'] = 'attachment; filename="somefilename.csv"'
      return response
  ```

#### FileResponse

* https://docs.djangoproject.com/en/3.0/ref/request-response/#fileresponse-objects

  ```python
  >>> from django.http import FileResponse
  >>> response = FileResponse(open('myfile.png', 'rb'))
  ```

[목차로 이동](#목차)   

## 3. Django Form

### 주요 역할

* 입력폼  HTML  생성

* 입력폼에 대한 유효성 검증

* 검증을 통과한 값을  dict  형태로 제공

  ```python
  #	myapp/forms.py
  from django	import forms
  class PostForm(forms.Form):
      title	=	forms.CharField() #TextField는 사용하지 않음
      content	=	forms.CharField(widget=form.Textarea) #widget에서 특별히 변경가능
  ```

* 장고 forms는 user와 interaction을 한다.

* POST/GET 방식을 처리하는 Form  처리하는 일반적인 예제

``` python
def post_new(request):
    if request.method	==	'POST':
    	form	=	PostForm(request.POST,	request.FILES) # 파라미터 순서를 지켜줘야 한다.
        if form.is_valid(): #유효성 검증이 통과하면
            post	=	Post(**form.cleaned_data)
            post.save()
            return redirect(post)
    else: #GET 방식
    	form	=	PostForm()
        
    return render(request,	'blog/post_form.html',	{
    	'form':	form,
	})
```

### Form 사용의 문제점

* Form 과 model은 서로 독립적이다. 
* 그러나 구현할 때는 모델과 폼을 연계하여 구현한다.
* 그래서 모델이 변경되면 폼도 변경된다.
* 유지보수의 문제가 발생하게 된다.
* 이 문제를 해결하기 위해 ModelForm 이란 것이 있다.



### ModelForm

#### 유효성 검사 

```python
#	myapp/models.py
from django	import forms
from django	import models

def min_length_3_validator(value): #유효성 검사 함수 정의
	if len(value)	<	3:
	raise forms.ValidationError('3글자 이상 입력해주세요.')
 
#유효성 검사 로직은 모델에서만 구현하면 된다.
#form에서 구현하지 말고...
class Post(forms.Model):
    title   = models.CharField(max_length=100,validators=[min_length_3_validator]) #유효성 검사 로직 적용
    content	= models.TextField()

#	myapp/forms.py
from django	import forms
from .models import Post

class PostForm(forms.ModelForm):
	class Meta:
		model = Post  #모델에서 정의된 validator 정보를 가져온다.ㅊ
		fields = '__all__'
```

#### view  함수내에서 처리

```python
# myapp/views.py
from .forms import PostForm
if request.method == 'POST':
	# POST 요청일 때
	form = PostForm(request.POST, request.FILES)
else:
	# GET 요청일 때
	form = PostForm()
```

#### view에서 유효성 검증

```python
if request.method == 'POST':
    # POST인자는 request.POST와 request.FILES를 제공받음.
    form = PostForm(request.POST, request.FILES)
    # 인자로 받은 값에 대해서, 유효성 검증 수행
    if form.is_valid(): # 검증이 성공하면, True 리턴
        # 검증에 성공한 값들을 사전타입으로 제공받음.
        # 검증에 성공한 값을 제공받으면, Django Form의 역할은 여기까지 !!!
        # 필요에 따라, 이 값을 DB에 저장하기
        form.cleaned_data
        post = Post(**form.cleaned_data) # DB에 저장하기
        post.save()
		return redirect('/success_url/')
	else: # 검증에 실패하면, form.errors와 form.각필드.errors 에 오류정보를 저장
		form.errors
else: # GET 요청일 때
    form = PostForm()
    return render(request, 'myapp/form.html', {'form': form})
```

#### 템플릿 적용

* Get 요청일때: Form을 채우고 submit하고 POST 요청

* POST  요청 

  ```python
  <table>
      <form action="" method="post">
          {% csrf_token %}
          <table>{{ form.as_table }}</table>
          <input type="submit" />
      </form>
  </table>
  ```

####  Form Fields

* Model Fields와 유사하다
* Models Fields는 Data Fields 들을 파이썬 클래스화
* Form Fields는  HTLM  Form Field 들을 파이썬 클래스화 
* https://docs.djangoproject.com/en/3.0/ref/forms/fields/



[목차로 이동](#목차)   

## 4. CSR

[목차로 이동](#목차)   

## 5. ModelForm

[목차로 이동](#목차)   

## 6. Form Valication

[목차로 이동](#목차)   

## 7. Message Framework

[목차로 이동](#목차)   

## 8. Forms를 통한 삭제 구현

[목차로 이동](#목차)   

