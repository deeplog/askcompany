# 장고 Views



목차  
------

[1. 함수 기반 뷰](#함수-기반-뷰)   

[2. URL Dispatcher와 정규 표현식](#URL-Dispatcher와-정규-표현식)

[3. Class Based View](#Class-Based-View)

[4. 장고 기본 CBV API](#장고-기본-CBV-API)

* [Built-in CBV API](#Built-in-CBV-API)
* [Base Views](#Base-Views)
* [Generic display views](#Generic-display-views)
* [django-bootstrap4](#django-bootstrap4)



## 함수 기반 뷰 

### view 란?

view는 1개의  http의 요청에 대해 1개의 뷰가 호출됨   
뷰는 urlpatterns 리스트에 매핑된 함수 (또는 호출 가능한 객체) 이다.
두가지 형태의 뷰

* 함수기반 뷰 (Function Based View)
* 클래스 기반 뷰 (Class Based View)

### view 인자
1번째 인자: HttpRequest 객체   
2번재 인자: URL Captured Values

```python
# urls.py
urlpatterns = [
    path('', views.post_list),
    path('<int:pk>/', views.post_detail)
]
# views.py
def post_detail(request, pk):
    pass
```

### view 리턴값

[HttpResponse 객체 리턴](https://docs.djangoproject.com/en/4.1/ref/request-response/#django.http.HttpResponse)   
다른 타입을 리턴하면 Middleware에서 오류 처리함


``` python
# view에서 None을 리터하는 경우
def post_detail(request, pk):
    pass

# error 메세지
htmlValueError at /instagram/1/
The view instagram.views.post_detail didn't return an HttpResponse object. It returned None instead.
Request Method:	GET
Request URL:	http://127.0.0.1:8000/instagram/1/
Django Version:	3.2.15
Exception Type:	ValueError
Exception Value:	
The view instagram.views.post_detail didn't return an HttpResponse object. It returned None instead.
```

**HTTPRequest와 Http Response 예시**

```python
def post_list(reqeust):
    qs = Post.objects.all()
    q = reqeust.GET.get('q','') # q key가 있으면 가져오고, 없으면 ''
    if q:
        qs = qs.filter(message__icontains=q) # 필터링 기능 구현이 됨
        #instagram/templates/instagram/post_list.html
    return render(reqeust, 'instagram/post_list.html', {
        'post_list':qs,
        'q':q,
        })
```

[장고 관련 문서](https://docs.djangoproject.com/en/4.1/ref/request-response/)

### HttpResponse
[목차](#목차)   

### Excel 파일 다운로드 하기 
```python
from django.http import HttpResponse
from urllib.parse import quote
import os

def response_excel(request):
    filepath = '/other/path/excel.xls'
    filename = os.path.join(filepath)

    with open(filepath, 'rb') as f:
        response = HttpResponse(f, content_type='application/vnd.ms-excel')

        # 브라우저에 따라 다른 처리 필요
        # 장고의 FileResponse를 이용하면 더 수월하게 할 수 있다. 
        encoded_filename = quote(filename)
        response['Content-Disposition'] = "attachment; filename*=utf-8''{}".format(encoded_filename)

    return response
```

### Pandas 데이터 다운로드 하기
```python
import pandas as pd
from django.http import HttpResponse

def response_csv(request):
    df = pd.DataFrame([
        [100, 110, 120],
        [200, 210, 220],
        [300, 310, 320],
    ])

    response = HttpResponse(
        content_type='text/csv',
        headers={'Content-Disposition': 'attachment; filename="test.csv'},
    )
    df.to_csv(path_or_buf = response)
    return response
```



## URL Dispatcher와 정규 표현식



### URL Dispatcher

특정 URL 패턴이 왔을때 View에서 처리하는 매핑을 맺음

최상위 URL 패턴을 이용하여 include를 통해 Tree구조로 URL을 확장함

최상위 URL은 프로젝트/settings.py에서 ROOT_URLCONF 에 값을 지정함 



**urlpatterns 예시**

```python
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('blog1/', include('blog1.urls')),
    path('instagram/', include('instagram.urls')),
    path('accounts/', include('accounts.urls')),
    path('analysis/', include('analysis.urls')),
]
```



**매칭이 되는 URL 이 없는 경우**

`404 page not found` 응답이 발생한다. 



### path()와 re_path()

장고 1.x 에서는 Django.conf.urls.url() 사용이 path와 re_path로 분리됨 



예제

```python
from django.urls import path, re_path

urlpatterns = [
    path('article/<int:year>/', view.year_archieve) #아래와 동일한 표현임
    re_path(r'^article/(?P<year>[0-9]{4})/$', views.year_archive), #인자를 year로 지정해서 넘겨준다.
]
```



### 기본 제공되는 Path Converters

IntConverter → `r"[0-9]+"`  정수가 1회 이상 반복

StringConverter → `r"[^/]+"` /를 제외한 문자가 1회 이상 반복

UUIDConverter → `r"[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"`

SlugConverter → `r"[-a-zA-Z0-9_]+"`  -소문자대분자숫자_ 연속으로 1회 이상 반복되는 형태

PathConverter → `r".+"` 모든 문자열에 대해 1회 이상 반속



### 정규 표현식

```python
"[0123456789]"  혹은 [0-9] 혹은 r"[\d]"   : 1자리 숫자
"[0123456789][0123456789]"  혹은 [0-9][0-9] 혹은 r"[\d][\d][\d]"   : 2자리 숫자
r"\d\d\d" 혹은 r"\d{3}" : 3자리 숫자
r"\d{2,4}" 2~4자리 숫자
r"010[1-9]\d{7}" 휴대폰 번호
"[a-z]" 알파벳소문자 1글자
```



### 정규표현식 반복횟수 지정

```python
r"\d"    : 1회
r"\d{2}" : 2회
r"\d{2,4}": 2~4회
r"\d?" : 0회 혹은 1회
r"\d*" : 0회 이상
r"\d+" : 1회 이상
```



예제

```python
## urls.py
urlpatterns = [
    path('', views.post_list),
    path('<int:pk>/', views.post_detail),
    #path('archives/<int:year>/', views.archivs_year),
    re_path(r'archives/(?P<year>20\d{2})/', views.archivs_year)
]

## views.py
def archivs_year(request, year):
    return HttpResponse(f"{year}년 archives")
```



### 커스텀 path converter

사용자가 자주 쓰는 정규표현식은 클래스로  만든 다음   register_converter에 등록하고 사용한다.

```python
class YearConverter:
    regex = r'20\d{2}'

    def to_python(self, value):
        return int(value)
    
    def to_url(self, value):
        return str(value)

register_converter(YearConverter, 'year')

urlpatterns = [
    path(r'archives/<year:year>/', views.archives_year) #custom converter 사용하기
]
```



## Class Based View

예제

```python
class MyView(APIView): # 상속을 통해 만들어 준다. 
    throttle_classes =[OncePerDayUserThrottle]
    
    def get(self,  request):
        return Response({"message": "Hello for today!"})
```



장고 기본  CBV 패키지

* https://github.com/django/django/tree/main/django/views/generic  소스코드
* https://docs.djangoproject.com/en/4.1/topics/class-based-views/  공식문서



### CBV 구현하기

거의 비슷한 view를 여러개 구현해야 하는 경우?

```python
def post_detail(request, id):
    post = get_object_or_404(Post, id=id) #없으면 404 에러 반환
    return render(request, 'blog/post_detail.html'), {
        'post': post, 
    })
    
    
def article_detail(request, id):
    article = get_object_or_404(Article, id=id)
    return render(request, 'blog/article_detail.html', {
        'article': article,
    }) 
```

class based view로 구현하기 (기능상 동일한 구현임)

실제 장고 기본 제공 CBV가 구현하는 방식임

Refactoring  할때 일반적으로 함수를 클래스로 바꾼다.

```python
class DetailView:
    def __init__(self, model):
        self.model = model
     
    @classmethod
    def as_view(cls, model):
        def view(request, *args, **kwargs):
            self = cls(model) #클래스의 인스턴스를 만든다.
            object = get_object_or_404(self.model, id=kwagrs['id'])
            template = f'{self.model._meta.app_label}/{self.model._meta.model_name}'
            return render(request, template, {
            	self.model._meta.model_name: object,
            })
        return view
 
post_detail = DetailView.as_view(Post)
article_detail = DetailView.as_view(Article)
```

### 장고 기본 제공 CBV

```python
from django.views.generic import DetailView

post_detail = DetailView.as_view(model=Post)
```

※ 주의사항: 규격에 맞는 html을 미리 템플릿으로 만들어 놓아야 한다. 



## 장고 기본 CBV API

### Built-in CBV API

* Base views

* Generic display views
* Generic date views
* Generic editing views



### Base Views

#### View

모든 CBV의 모체



####  TemplateView

TemplateView 사용법 예제

템플릿 html을 열어준다. 

```python 
#askcompany/urls.py

from django.views.generic import TemplateView

urlpatterns = [
    path('', TemplateView.as_view(template_name='root.html'), name='root'),
]

#askcompany/settings.py
TEMPLATES = [
    {
        'DIRS': [
            # File System Template Loader
            os.path.join(BASE_DIR, 'askcompany', 'templates'),
        ],
    },
]
```



#### RedirectView

예제 1. url로 redirect

```python
#프로젝트/urls.py
path('',RedirectView.as_view(url='/instagram/'), name='root'),
```



예제 2. Pattern으로 redirect (장고에서 선호하는 방식)

```python
#프로젝트/urls.py
urlpatterns = [
    path('',RedirectView.as_view(pattern_name='instagram:post_list'),name='root'),
]
#앱/urls.py
app_name = 'instagram' # URL Reverse에서 Name Spaece 역할을 함
urlpatterns = [
    path('', views.post_list, name='post_list'),
]
```



### Generic display views

#### DetailView

1개의 모델의 1개의 오브젝트에 대한 탬플릿 처리

필요에 따라 html, excel, json 응답으로 할 수 있다.

pk, slug에 해당하는 필드를 내부적으로 찾아서 실행한다.

TemplateName을 지정하지 않으면 내부적으로 모델명으로 유추해서 실행한다. (추천하는 방식)

SingleObjectMixin 상속



Case 1. DetailView 사용하기

```python
from django.views.generic import DetailView
form .models import Post

post_detail = DetailView.as_view(model=Post)
```



Case2. DetailView 상속하기

```python
from django.views.generic import DetailView
form .models import Post

class PostDetailView(DetailView):
    model = Post
   
post_detail = PostDetailView.as_view()
```



Case 3. 로그인에 따른 기능 구현

```python
class PostDetailView(DetailView):
    model = Post

    def get_queryset(self):
        qs = super().get_queryset()
        if not self.request.user.is_authenticated:
            qs = qs.filter(is_public=True)
        return qs

post_detail = PostDetailView.as_view()
```



#### ListView

특징

* 1개의 모델에 대한 List 템플릿(html 이외에도 다른 응답이 가능) 처리

* 모델명소문자_list 이름의 QuerySet을 템플릿에 전달

* <span style="color:red"> **페이징 처리 지원** </span>

  

상속관계

* MultipleObjectTemplateResponseMixin
  * 모델명으로 템플릿 경로 유추
  * 탬플릿 기능 제공
* BaseListView
  * MultipleObjectMixin 상속: pagination 기능 제공



Case 1. ListView 사용하기

```python
from django.views.generic import Listview
form .models import Post

post_list1 = ListView.as_view(model=Post)

post_list2 = ListView.as_view(model=Post, paginate_by=10) #페이징, get에서 page=1로 가져옴
```



Case2. ListView 상속

```python
class PostListView(ListView):
    model = Post
    paginate_by = 10
    
post_list3 = PostListView.as_view()
```



Case3. queryset 재정의

```python
class PostListView(ListView):
    model = Post
    paginate_by = 10
    
    def get_queryset(self):
        qs = super().get_queryset()
        qs = qs.filter(...)
        return qs
    
post_list4 = PostListView.as_view()
```



Test용 데이터 랜덤으로 생성하기

```python
post_list = list(Post.objects.all())
for i in range(100):
    post= random.choice(post_list)
    post.pk = None
    post.save()
```



**Case4. Pagination** 

```python
# def post_list(reqeust):
#     qs = Post.objects.all()
#     q = reqeust.GET.get('q','') # q key가 있으면 가져오고, 없으면 ''
#     if q:
#         qs = qs.filter(message__icontains=q) # 필터링 기능 구현이 됨
#         #instagram/templates/instagram/post_list.html
#     return render(reqeust, 'instagram/post_list.html', {
#         'post_list':qs,
#         'q':q,
#         })

#ListView 활용 및 pagination
post_list = ListView.as_view(model=Post, paginate_by=10)
```



### django-bootstrap4

```python
> pip install django-bootstrap4

INSTALLED_APPS = [
    ...
    # third apps
    'bootstrap4',
    ...
]
```



pagination을 위한 bootstrap 템플릿 적용

```html
instagram/post_list.html 

{% load bootstrap4 %}

...
{% bootstrap_pagination page_obj size="large"%}
```



## View Decorators

### Decorators 

어떤 함수를 감싸는(wrapping) 함수

함수위에 @ 를 써서 표현한다. 



decorator를 사용하지 않는 경우

```python
from django.contrib.auth.decorators import login_required
form django.shortcuts import render

def protected_view1(request):
    return render(request, 'myapp/secret.html')

protected_view1 = login_required(protected_view1)
```



decorator를 사용하는 경우

```python
@login_required
def protected_view1(request):
    return render(request, 'myapp/secret.html')
```



### django 기본 decorators

#### django.views.decorators.http

* require_http_methods:  지정한 메쏘드만 허용
* require_GET: get 요청만 받겠다.
* require_POST: post 요청만 받겠다.
* require_safe: 조회목적의 http 매쏘드, HEAD 요청 같은 경우  어떤 매쏘드 허용 하는지 알 수있다.

#### djaongo.contrib.auth.decorators

* user_passes_test:  user가 어떤 조건을 통과하지 못하면  login_url로 redirect

* login_required: 로그아웃 상황에서 login_url로 redirect

  ```python
  @login_required
  def post_list(reqeust):
      qs = Post.objects.all()
      q = reqeust.GET.get('q','') # q key가 있으면 가져오고, 없으면 ''
      if q:
          qs = qs.filter(message__icontains=q) # 필터링 기능 구현이 됨
          #instagram/templates/instagram/post_list.html
      return render(reqeust, 'instagram/post_list.html', {
          'post_list':qs,
          'q':q,
          })
  ```

* permission_required: 지정 퍼미션이 없을 때, login_url로 redirect

#### django.contrib.admin.views.decorators

* staff_member_required

  admin 에서 로그인한 다음에 users에 가면 permission에 가면 staff 권한이 있는지 알 수 있다. 

  permission이 있는 항목에 대해서만 admin에서 해당 항목에 대한 권한을 가질 수 있다.



### CBV에 장식자 입히기



요청을 처리하는 함수를 wrapping 하기

```python
from django.contrib.auth.decorators import login_required
from django.views.generic import TemplateView

class SecretView(TemplateView):
    template_name = 'myapp/secret.html'
    
view_fn = SecretView.as_view()
secret_view = login_required(view_fn)
```



맴버함수에 장식자를 입혀서 사용한다. 

```python
from django.contrib.auth.decorators import login_required
from django.utils.decorators import method_decorator
from django.views.generic import TemplateView

class SecretView(TemplateView):
    template_name = 'myapp/secret.html'
    
    @method_decorator(login_required)
    def dispatch(self, *args, **kwargs): #request가 오면 처리되는 멤버 함수
        return super().dispatch(*args, **kwargs)
    
view_fn = SecretView.as_view()
```



클래스 자체에 장식자를 입히는 방법

```python
from django.contrib.auth.decorators import login_required
from django.utils.decorators import method_decorator
from django.views.generic import TemplateView

@methode_decorator(login_required, name='dispatch')
class SecretView(TemplateView):
    template_name = 'myapp/secret.html'
    
view_fn = SecretView.as_view()
```





장식자가 아니라 mixin을 활용하는 방법도 있다. [loginrequired-mixin 공식문서](https://docs.djangoproject.com/en/4.1/topics/auth/default/#the-loginrequired-mixin)

```python
from django.contrib.auth.mixins import LoginRequiredMixin

class MyView(LoginRequiredMixin, View): #view에  LoginRequireMixin 적용
    login_url = '/login/'
    redirect_field_name = 'redirect_to'
```



